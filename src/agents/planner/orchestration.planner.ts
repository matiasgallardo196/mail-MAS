import { z } from 'zod';
import type { PlannerOptions } from '../../shared/types/agent';
import type { ToolDef } from '../../shared/types/tool';
import type { Roster } from '../../shared/types/roster';
import type { ComplianceResult, ComplianceIssue } from '../../shared/types/compliance';

const PlannerBase = (() => {
  try {
    return require('@openai/agents').Planner;
  } catch (err) {
    return class {
      name?: string;
      instructions?: string;
      tools?: ToolDef[];
      constructor(opts: PlannerOptions = { name: 'fallback' } as PlannerOptions) {
        this.name = opts.name;
        this.instructions = opts.instructions;
        this.tools = opts.tools as ToolDef[];
      }
    };
  }
})();

// ═══════════════════════════════════════════════════════════════════
// Orchestration Flow State
// ═══════════════════════════════════════════════════════════════════

/**
 * Possible states of the scheduling process
 */
export type OrchestrationState =
  | 'INITIAL'                    // Initial state
  | 'ROSTER_GENERATED'           // Roster generated by RosterWorker
  | 'COMPLIANCE_VALIDATED'       // Validated by ComplianceWorker
  | 'COMPLIANCE_HAS_ISSUES'      // Has issues to resolve
  | 'CONFLICTS_RESOLVED'         // Conflicts resolved by ConflictWorker
  | 'OPTIMIZED'                  // Optimized by OptimizationWorker
  | 'FINAL_VALIDATION_PASSED'    // Final validation OK
  | 'FINAL_VALIDATION_FAILED'    // Final validation failed
  | 'REQUIRES_HUMAN_REVIEW'      // Cannot be resolved automatically
  | 'COMPLETED';                 // Process completed

/**
 * Workers available in the system
 */
export type WorkerName = 
  | 'RosterWorker' 
  | 'ComplianceWorker' 
  | 'ConflictWorker' 
  | 'OptimizationWorker';

/**
 * Planner decision about what to do next
 */
export interface PlannerDecision {
  nextWorker: WorkerName | 'DONE' | 'HUMAN_REVIEW';
  reason: string;
  shouldRetry?: boolean;
  maxRetries?: number;
}

/**
 * Context for making decisions
 */
export interface PlannerContext {
  currentState: OrchestrationState;
  roster: Roster | null;
  compliance: ComplianceResult | null;
  iterationCount: number;
  maxIterations: number;
  hasCriticalIssues: boolean;
  hasSuggestions: boolean;
  hasUnresolvedGaps: boolean;
  optimizationAttempted: boolean;
}

// ═══════════════════════════════════════════════════════════════════
// Input/Output Schemas for Tools
// ═══════════════════════════════════════════════════════════════════

const PlannerContextSchema = z.object({
  currentState: z.enum([
    'INITIAL',
    'ROSTER_GENERATED',
    'COMPLIANCE_VALIDATED',
    'COMPLIANCE_HAS_ISSUES',
    'CONFLICTS_RESOLVED',
    'OPTIMIZED',
    'FINAL_VALIDATION_PASSED',
    'FINAL_VALIDATION_FAILED',
    'REQUIRES_HUMAN_REVIEW',
    'COMPLETED',
  ]),
  hasRoster: z.boolean(),
  shiftsCount: z.number(),
  hasCriticalIssues: z.boolean(),
  hasMajorIssues: z.boolean(),
  hasSuggestions: z.boolean(),
  hasUnresolvedGaps: z.boolean(),
  optimizationAttempted: z.boolean(),
  iterationCount: z.number(),
  maxIterations: z.number(),
});

const PlannerDecisionSchema = z.object({
  nextWorker: z.enum(['RosterWorker', 'ComplianceWorker', 'ConflictWorker', 'OptimizationWorker', 'DONE', 'HUMAN_REVIEW']),
  reason: z.string(),
  shouldRetry: z.boolean().optional(),
  maxRetries: z.number().optional(),
});

// ═══════════════════════════════════════════════════════════════════
// Planner Logic
// ═══════════════════════════════════════════════════════════════════

/**
 * Decides which worker to execute next based on state
 */
function selectNextWorker(context: z.infer<typeof PlannerContextSchema>): PlannerDecision {
  const { 
    currentState, 
    hasRoster, 
    hasCriticalIssues, 
    hasSuggestions, 
    hasUnresolvedGaps,
    optimizationAttempted,
    iterationCount,
    maxIterations,
  } = context;

  // Guard: too many iterations
  if (iterationCount >= maxIterations) {
    return {
      nextWorker: 'HUMAN_REVIEW',
      reason: `Maximum of ${maxIterations} iterations reached without resolving all issues`,
    };
  }

  // State machine
  switch (currentState) {
    case 'INITIAL':
      return {
        nextWorker: 'RosterWorker',
        reason: 'Initial state - generate roster',
      };

    case 'ROSTER_GENERATED':
      return {
        nextWorker: 'ComplianceWorker',
        reason: 'Roster generated - validate compliance',
      };

    case 'COMPLIANCE_VALIDATED':
      if (!hasCriticalIssues && !hasSuggestions && !hasUnresolvedGaps) {
        // Valid roster, move to optimization
        return {
          nextWorker: 'OptimizationWorker',
          reason: 'Compliance OK without issues - optimize costs',
        };
      }
      // Has issues, move to ConflictWorker
      return {
        nextWorker: 'ConflictWorker',
        reason: 'Compliance has issues/suggestions - resolve conflicts',
      };

    case 'COMPLIANCE_HAS_ISSUES':
      if (hasCriticalIssues && !hasSuggestions) {
        // Critical issues without suggestions → human review
        return {
          nextWorker: 'HUMAN_REVIEW',
          reason: 'Critical issues without automatic suggestions',
        };
      }
      return {
        nextWorker: 'ConflictWorker',
        reason: 'There are issues to resolve',
      };

    case 'CONFLICTS_RESOLVED':
      if (hasUnresolvedGaps || hasCriticalIssues) {
        // Still problems after ConflictWorker
        return {
          nextWorker: 'HUMAN_REVIEW',
          reason: 'Conflicts not fully resolved',
        };
      }
      if (!optimizationAttempted) {
        return {
          nextWorker: 'OptimizationWorker',
          reason: 'Conflicts resolved - optimize costs',
        };
      }
      // Already optimized, final validation
      return {
        nextWorker: 'ComplianceWorker',
        reason: 'Post-optimization - final validation',
      };

    case 'OPTIMIZED':
      return {
        nextWorker: 'ComplianceWorker',
        reason: 'Optimization complete - final validation',
      };

    case 'FINAL_VALIDATION_PASSED':
      return {
        nextWorker: 'DONE',
        reason: 'Final validation successful',
      };

    case 'FINAL_VALIDATION_FAILED':
      if (hasCriticalIssues) {
        return {
          nextWorker: 'HUMAN_REVIEW',
          reason: 'Final validation failed with critical issues',
        };
      }
      return {
        nextWorker: 'ConflictWorker',
        reason: 'Final validation failed - attempt to resolve',
        shouldRetry: true,
        maxRetries: 2,
      };

    case 'REQUIRES_HUMAN_REVIEW':
    case 'COMPLETED':
      return {
        nextWorker: 'DONE',
        reason: 'Process completed',
      };

    default:
      return {
        nextWorker: 'HUMAN_REVIEW',
        reason: `Unknown state: ${currentState}`,
      };
  }
}

/**
 * Evalúa la calidad del roster actual
 */
function evaluateRosterQuality(context: z.infer<typeof PlannerContextSchema>): {
  score: number;
  canProceed: boolean;
  issues: string[];
} {
  const issues: string[] = [];
  let score = 100;

  if (!context.hasRoster) {
    return { score: 0, canProceed: false, issues: ['No roster generated'] };
  }

  if (context.shiftsCount === 0) {
    issues.push('Empty roster - no shifts assigned');
    score -= 50;
  }

  if (context.hasCriticalIssues) {
    issues.push('Has critical compliance issues');
    score -= 40;
  }

  if (context.hasMajorIssues) {
    issues.push('Has major compliance issues');
    score -= 20;
  }

  if (context.hasUnresolvedGaps) {
    issues.push('Has unresolved coverage gaps');
    score -= 30;
  }

  const canProceed = score >= 60 && !context.hasCriticalIssues;

  return { score: Math.max(0, score), canProceed, issues };
}

// ═══════════════════════════════════════════════════════════════════
// OrchestrationPlanner Class
// ═══════════════════════════════════════════════════════════════════

/**
 * OrchestrationPlanner - Dynamically decides the worker flow
 *
 * Responsibilities:
 * - Evaluate the current state of the process
 * - Decide which worker should execute next
 * - Determine when the process should end
 * - Detect situations that require human intervention
 *
 * The planner acts as the "brain" of the orchestrator, making
 * decisions based on the roster state and the results
 * of each worker.
 */
export class OrchestrationPlanner extends PlannerBase {
  constructor() {
    super({
      name: 'OrchestrationPlanner',
      instructions: `
        You are the scheduling planner for McDonald's. Your role is to coordinate
        the execution sequence of workers to generate an optimal roster.

        AVAILABLE WORKERS:
        - RosterWorker: Generates shifts based on availability and requirements
        - ComplianceWorker: Validates Fair Work Act and generates suggestions
        - ConflictWorker: Resolves conflicts and applies corrections
        - OptimizationWorker: Optimizes roster costs

        TYPICAL FLOW:
        1. RosterWorker → generates initial roster
        2. ComplianceWorker → validates compliance
        3. If there are issues → ConflictWorker → resolves
        4. OptimizationWorker → optimizes costs
        5. ComplianceWorker → final validation
        6. DONE or HUMAN_REVIEW

        RULES:
        - If there are CRITICAL issues without suggestions → HUMAN_REVIEW
        - Maximum 5 iterations before HUMAN_REVIEW
        - Always end with final compliance validation
        - Prioritize resolving critical issues over optimization

        EVALUATE the roster quality and DECIDE the next step.
      `,
      tools: [
        // Tool 1: Select next worker
        {
          type: 'function',
          function: {
            name: 'select_next_worker',
            description: 'Decides which worker should execute next based on the current state of the process',
            parameters: PlannerContextSchema,
            execute: async (args: unknown): Promise<PlannerDecision> => {
              const context = PlannerContextSchema.parse(args);
              return selectNextWorker(context);
            },
          },
        },
        // Tool 2: Evaluate roster quality
        {
          type: 'function',
          function: {
            name: 'evaluate_roster_quality',
            description: 'Evaluates the quality of the current roster and determines if it can proceed',
            parameters: PlannerContextSchema,
            execute: async (args: unknown): Promise<{ score: number; canProceed: boolean; issues: string[] }> => {
              const context = PlannerContextSchema.parse(args);
              return evaluateRosterQuality(context);
            },
          },
        },
        // Tool 3: Determine if process should terminate
        {
          type: 'function',
          function: {
            name: 'should_terminate',
            description: 'Determines if the orchestration process should terminate',
            parameters: z.object({
              currentState: z.string(),
              iterationCount: z.number(),
              hasCriticalIssues: z.boolean(),
              qualityScore: z.number(),
            }),
            execute: async (args: unknown): Promise<{ terminate: boolean; reason: string; status: string }> => {
              const input = z.object({
                currentState: z.string(),
                iterationCount: z.number(),
                hasCriticalIssues: z.boolean(),
                qualityScore: z.number(),
              }).parse(args);

              // Termination conditions
              if (input.currentState === 'COMPLETED' || input.currentState === 'FINAL_VALIDATION_PASSED') {
                return { terminate: true, reason: 'Process completed successfully', status: 'ok' };
              }

              if (input.currentState === 'REQUIRES_HUMAN_REVIEW') {
                return { terminate: true, reason: 'Requires human review', status: 'requires_human_review' };
              }

              if (input.iterationCount >= 5) {
                return { terminate: true, reason: 'Maximum iterations reached', status: 'partial' };
              }

              if (input.hasCriticalIssues && input.iterationCount >= 3) {
                return { terminate: true, reason: 'Critical issues not resolved', status: 'requires_human_review' };
              }

              return { terminate: false, reason: 'Continue process', status: 'in_progress' };
            },
          },
        },
      ] as ToolDef[],
    });
  }

  /**
   * Helper method to get the next step decision
   * Can be used directly by the orchestrator
   */
  getNextStep(context: PlannerContext): PlannerDecision {
    return selectNextWorker({
      currentState: context.currentState,
      hasRoster: context.roster !== null,
      shiftsCount: context.roster?.roster.length ?? 0,
      hasCriticalIssues: context.hasCriticalIssues,
      hasMajorIssues: context.compliance?.issues?.some(i => i.severity === 'MAJOR') ?? false,
      hasSuggestions: context.hasSuggestions,
      hasUnresolvedGaps: context.hasUnresolvedGaps,
      optimizationAttempted: context.optimizationAttempted,
      iterationCount: context.iterationCount,
      maxIterations: context.maxIterations,
    });
  }

  /**
   * Evaluates if the process should continue or terminate
   */
  shouldContinue(context: PlannerContext): boolean {
    const decision = this.getNextStep(context);
    return decision.nextWorker !== 'DONE' && decision.nextWorker !== 'HUMAN_REVIEW';
  }
}
